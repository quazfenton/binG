# 0815 Audit + Plan

Append-only policy: Do not overwrite this file. For any future updates, append a new dated iteration at the end with the same sections.

Created: 2025-08-15


Goals:
-Check for areas of improvement
- Fix currently nonworking API calls and fallbacks
-Fix incoming response stream/animation/display which glitches and doesnt stream, just abruptly shows full response only after it is complete.   improve stability of streaming in the interface. lso, chat message bubbles currently sometimes too narrow or go off screen
- Integrate /home/kwasifenton/binG/enhanced-code-system/enhanced-code-orchestrator.ts   components/code-mode.tsx  for prompts sent when user has selected the "Code"option in components/interaction-panel.tsx
and Ensure consistency and safety in code diff/edit operations
- Fix/finish account login option in components/accessibility-controls.tsx
- Flesh out robust plugins in components/plugins


Success metrics (examples):
- p95 time-to-first-token (TTFT)
- p95 end-to-end response latency
- Streaming error rate (% aborted/retried)
- Mobile input focus reliability and layout shift (CLS) on small screens
- Autosuggest acceptance rate vs. dismiss rate; suggestion latency
- Edit/diff application success rate and conflict incidence
- SLA adherence for provider timeouts and fallback success rate

---

## Streaming Fix Plan
1. Transport and buffering
   - Standardize on Server-Sent Events (SSE) or WebSocket with minimal framing; ensure chunked transfer enabled
   - Disable proxy buffering for SSE endpoints; set appropriate Cache-Control: no-store
   - Send heartbeats every 15–30s to keep connections alive
2. Tokenization and chunking
   - Emit tokens in natural boundaries (words/sentence breaks) where feasible
   - Coalesce ultra-small chunks (<5–10 chars) to avoid excessive DOM updates
3. Backpressure and flow control
   - Throttle UI rendering using requestAnimationFrame batching
   - Buffer cap (e.g., 1–2KB) with overflow strategy: drop-oldest UI frames, never drop server data
4. Error handling and retries
   - Use idempotent request IDs; on disconnect, support resume-from-offset when provider allows
   - Retry policy: exponential backoff with jitter, max 3 attempts; surface partial output with a “resume” action
5. Partial rendering & UX
   - Show typing indicator and TTFT skeleton; lock layout height to reduce layout shift
   - Maintain scroll anchoring; provide “Jump to latest” button when scrolled up
6. Observability
   - Log TTFT, tokens/sec, completion latency; attach request IDs to logs
   - Capture client-side abort reasons (navigation, network change, visibility hidden)
7. Timeouts
   - Client soft-timeout to show nudge after N seconds; server hard-timeout aligned with provider SLAs

---

## Mobile UX Fix Plan
1. Layout & responsiveness
   - Use mobile-first breakpoints; test at 320/360/390/414 widths
   - Ensure input bar is fixed above keyboard using safe-area insets (env(safe-area-inset-bottom))
2. Keyboard & focus
   - Prevent input from losing focus on re-render; debounce state updates
   - Avoid auto-scrolling loops; use scrollIntoView({block: 'nearest'})
3. Touch targets & gestures
   - Minimum 44px touch targets; add pull-to-dismiss for expanded panels
   - Swipe actions consistent with platform (iOS/Android)
4. Performance
   - Virtualize long conversations; image lazy-loading; defer heavy work off main thread (Web Worker where applicable)
5. Accessibility
   - Proper labels, roles, and focus management; high-contrast mode; dynamic type support
6. Offline & flaky network
   - Indicate reconnecting state; local draft persistence; retry sends on regain

---


## Diff/Edit Consistency Plan
1. Operation model
   - Use minimal, anchored diffs with unique context before/after to ensure deterministic application
   - Enforce idempotency: reapplying same diff should be a no-op
2. Conflict handling
   - Preflight check: verify expected anchors exist; if mismatch, prompt user with a three-way diff
   - Versioning with content hash to detect drift between proposal and apply
3. Atomicity
   - Apply multi-file edits atomically when possible; otherwise order by dependency and rollback on failure
4. UX and safety
   - Preview pane with inline conflicts; explicit “Apply” action; clear success/failure toast with details
5. Tests
   - Golden tests for patch application across edge cases (CRLF/LF, trailing whitespace, tabs)

---

## Autosuggest Plan
1. Triggers
   - Debounce keystrokes (e.g., 300–500ms); only trigger above N chars or after punctuation
   - Respect user modes: coding vs. chat; disable in sensitive fields
2. Quality controls
   - Temperature capped low for suggestions; apply lexical filters to avoid repeating recent text
   - Rank by recency/context fit; cache last N suggestions per context key
3. UX
   - Ghost text or inline chip with Tab/Right-arrow to accept; Esc to dismiss; small, stable UI
   - Provide quick toggle and “Why this suggestion?” tooltip
4. Safety & privacy
   - Do not send unsaved secrets; redact obvious tokens; allow local-only suggestions where possible
5. Telemetry
   - Log impressions, accepts, edits-after-accept; compute acceptance rate and churn

---

## Provider Defaults
1. Default selection
   - Choose provider by policy: reliability > latency > cost, configurable per workspace
2. Model catalogs
   - Maintain allowlist with capabilities (tools, JSON mode, vision); fallback mapping by capability
3. Timeouts & retries
   - Per-provider sane defaults; circuit breaker on consecutive failures; greylist temporarily on high error rate
4. Quotas & keys
   - Detect missing/invalid keys early; surface actionable errors; do not log secrets
5. Observability
   - Per-provider metrics dashboard: success rate, p95 latency, cost estimates

---

## Subfolder Traversal Notes
1. Scope control
   - Respect .gitignore/.ignore; configurable depth; exclude large/binary folders by default (node_modules, build, .venv)
2. Safety
   - Avoid following symlinks outside workspace unless explicitly allowed
   - Enforce file size limits and total traversal time budget
3. Performance
   - Batch and throttle file reads; memoize directory listings; stream results progressively
4. Determinism
   - Stable sort order; record traversal plan and filters for reproducibility

---

## Rollout/Test Plan
1. Phased rollout
   - Stage: dev → canary (1–5%) → beta (25–50%) → GA (100%)
   - Feature flags for streaming changes, autosuggest, and new controls
2. Test strategy
   - Unit tests for chunking/backpressure; integration tests for SSE/WebSocket
   - Snapshot tests for mobile layouts across key breakpoints
   - End-to-end flows for edit/diff application with conflict cases
3. Monitoring & SLOs
   - Define SLOs for TTFT, error rate; alerting thresholds and dashboards
4. Rollback plan
   - One-click flag disable; keep previous stable build artifacts; document manual recovery steps
5. UXR & feedback
   - Collect qualitative feedback from beta cohort; instrument lightweight in-product survey

---

End of iteration (2025-08-15). Future updates should append below this line with a new date.

